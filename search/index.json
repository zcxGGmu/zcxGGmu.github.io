[{"content":"0 前言 kernel: 4.14\narch: ARM64\nirq_chip: GICv2\n本文重点分析 Linux 中断子系统，中断是处理器用于异步处理外围设备请求的一种机制，可以说中断处理是操作系统管理外围设备的基石，此外系统调度、核间交互等都离不开中断，它的重要性不言而喻。来一张分层图：\n**硬件层：**最下层为硬件连接层，对应的是具体的外设与SoC的物理连接，中断信号是从外设到中断控制器，由中断控制器统一管理，再路由到处理器上； **硬件相关层：**这个层包括两部分代码，一部分是架构相关的，比如ARM64处理器处理中断相关，另一部分是中断控制器的驱动代码； **通用层：**这部分也可以认为是框架层，是硬件无关层，这部分代码在所有硬件平台上是通用的； **用户层：**这部分也就是中断的使用者了，主要是各类设备驱动，通过中断相关接口来进行申请和注册，最终在外设触发中断时，进行相应的回调处理； 本文不会详细分析GICv2的硬件原理，因为不同架构的中断控制器实现都不太一样，但这些 irq_chip 接入 Linux内核后关于中断初始化、中断处理流程的框架是相同的。之前看了关于 riscv AIA Linux support 的一组PATCH，对其中相当多的接口不理解，所以想通过本文搞清楚 Linux 中断框架，将框架和 irq_chip 相关的代码分离开来。\n1 硬件相关层 1.1 GIC驱动分析 设备信息添加 ARM平台的设备信息，都是通过Device Tree设备树来添加，设备树信息放置在arch/arm64/boot/dts/下：\n下图就是一个中断控制器的设备树信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // /arch/arm64/boot/dts/arm/foundation-v8.dts / { gic: interrupt-controller@2c001000 { compatible = \u0026#34;arm,cortex-a15-gic\u0026#34;, \u0026#34;arm,cortex-a9-gic\u0026#34;; #interrupt-cells = \u0026lt;3\u0026gt;; #address-cells = \u0026lt;2\u0026gt;; interrupt-controller; reg = \u0026lt;0x0 0x2c001000 0 0x1000\u0026gt;, \u0026lt;0x0 0x2c002000 0 0x2000\u0026gt;, \u0026lt;0x0 0x2c004000 0 0x2000\u0026gt;, \u0026lt;0x0 0x2c006000 0 0x2000\u0026gt;; interrupts = \u0026lt;1 9 0xf04\u0026gt;; }; }; **compatible字段：**用于与具体的驱动来进行匹配，比如图片中 arm, cortex-a15-gic ，可以根据这个名字去匹配对应的驱动程序； **interrupt-cells字段：**用于指定编码一个中断源所需要的单元个数，这个值为3。比如在外设在设备树中添加中断信号时，通常能看到类似 interrupts = \u0026lt;0 23 4\u0026gt;;的信息，第一个单元0，表示的是中断类型（1：PPI，0：SPI），第二个单元 23 表示的是中断号，第三个单元 4 表示的是中断触发的类型； **interrupt-controller字段：**表示该设备是一个中断控制器，外设可以连接在该中断控制器上； **reg字段：**描述中断控制器的地址信息以及地址范围，比如图片中分别制定了 GIC Distributor（GICD）和GIC CPU Interface（GICC）的地址信息； 关于设备数的各个字段含义，详细可以参考Documentation/devicetree/bindings下的对应信息； 设备树的信息，是怎么添加到系统中的呢？ Device Tree 最终会编译成 dtb 文件，并通过 Uboot 传递给内核，在内核启动后会将 dtb 文件解析成 device_node 结构。关于设备树的相关知识，本文先不展开，后续再找机会补充。来一张图，先简要介绍下关键路径：\n1 2 3 4 5 6 start_kernel +-\u0026gt; setup_arch +-\u0026gt; unflatten_device_stree //解析dtb文件 +-\u0026gt; unflatten_dt_nodes +-\u0026gt; populate_node +-\u0026gt; unflatten_dt_alloc 设备树的节点信息，最终会变成device_node结构，在内存中维持一个树状结构。设备与驱动，会根据compatible 字段进行匹配 。\n驱动流程分析 GIC驱动的执行流程如下图所示：\n关于链接脚本vmlinux.lds，脚本中定义了一个 __irqchip_of_table 段，该段用于存放中断控制器信息，用于最终来匹配设备； 在GIC驱动程序中，使用 IRQCHIP_DECLARE 宏来声明结构信息，包括 compatible 字段和回调函数，该宏会将这个结构放置到 __irqchip_of_table 段中； 在内核启动初始化中断的函数中，of_irq_init 函数会去查找设备节点信息，该函数的传入参数就是__irqchip_of_table 段，由于 IRQCHIP_DECLARE 已经将信息填充好了，of_irq_init 函数会根据arm,gic-400 去查找对应的设备节点，并获取设备的信息。中断控制器也存在级联的情况，of_irq_init 函数中也处理了这种情况； or_irq_init 函数中，最终会回调IRQCHIP_DECLARE声明的回调函数，也就是gic_of_init，而这个函数就是GIC驱动的初始化入口函数了； GIC的工作，本质上是由中断信号来驱动，因此**驱动本身的工作就是完成各类信息的初始化，**注册好相应的回调函数，以便能在信号到来之时去执行；\nset_smp_process_call 设置 __smp_cross_call 函数指向 gic_raise_softirq，本质上就是通过软件来触发GIC的 SGI中断 ，用于核间交互；\ncpuhp_setup_state_nocalls 函数，设置好CPU进行热插拔时GIC的回调函数，以便在CPU热插拔时做相应处理；\nset_handle_irq 函数的设置很关键，它将全局函数指针 handle_arch_irq 指向了 gic_handle_irq，而处理器在进入中断异常时，会跳转到 handle_arch_irq 执行，所以，可以认为它就是中断处理的入口函数了；\n驱动中完成了各类函数的注册，此外还完成了 irq_chip, irq_domain 等结构体的初始化，这些结构在下文会进一步分析。最后，完成GIC硬件模块的初始化设置，以及电源管理相关的注册等工作；\n我们可以看到，gic_* 作为前缀的函数都是和特定的GIC中断控制器相关的，如果换作RISC-V架构，这些函数就会被替换为 plic_*/aplic_* 等等。\n数据结构分析 各数据结构的依赖关系如下图：\nGIC驱动中，使用 struct gic_chip_data 结构体来描述GIC控制器的信息，整个驱动都是围绕着该结构体的初始化，驱动中将函数指针都初始化好，实际的工作是由中断信号触发，也就是在中断来临的时候去进行回调。\nstruct irq_chip 结构，描述的是中断控制器的底层操作函数集，这些函数集最终完成对控制器硬件的操作 struct irq_domain结构，用于硬件中断号和Linux IRQ中断号（virq，虚拟中断号）之间的映射； 还是上一下具体的数据结构代码吧，关键注释如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 struct irq_chip { struct device\t*parent_device; //指向父设备 const char\t*name; // /proc/interrupts中显示的名字 unsigned int\t(*irq_startup)(struct irq_data *data); //启动中断，如果设置成NULL，则默认为enable void\t(*irq_shutdown)(struct irq_data *data); //关闭中断，如果设置成NULL，则默认为disable void\t(*irq_enable)(struct irq_data *data); //中断使能，如果设置成NULL，则默认为chip-\u0026gt;unmask void\t(*irq_disable)(struct irq_data *data); //中断禁止 void\t(*irq_ack)(struct irq_data *data); //开始新的中断 void\t(*irq_mask)(struct irq_data *data); //中断源屏蔽 void\t(*irq_mask_ack)(struct irq_data *data); //应答并屏蔽中断 void\t(*irq_unmask)(struct irq_data *data); //解除中断屏蔽 void\t(*irq_eoi)(struct irq_data *data); //中断处理结束后调用 int\t(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force); //在SMP中设置CPU亲和力 int\t(*irq_retrigger)(struct irq_data *data); //重新发送中断到CPU int\t(*irq_set_type)(struct irq_data *data, unsigned int flow_type); //设置中断触发类型 int\t(*irq_set_wake)(struct irq_data *data, unsigned int on); //使能/禁止电源管理中的唤醒功能 void\t(*irq_bus_lock)(struct irq_data *data); //慢速芯片总线上的锁 void\t(*irq_bus_sync_unlock)(struct irq_data *data); //同步释放慢速总线芯片的锁 void\t(*irq_cpu_online)(struct irq_data *data); void\t(*irq_cpu_offline)(struct irq_data *data); void\t(*irq_suspend)(struct irq_data *data); void\t(*irq_resume)(struct irq_data *data); void\t(*irq_pm_shutdown)(struct irq_data *data); void\t(*irq_calc_mask)(struct irq_data *data); void\t(*irq_print_chip)(struct irq_data *data, struct seq_file *p); int\t(*irq_request_resources)(struct irq_data *data); void\t(*irq_release_resources)(struct irq_data *data); void\t(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg); void\t(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg); int\t(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state); int\t(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state); int\t(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info); void\t(*ipi_send_single)(struct irq_data *data, unsigned int cpu); void\t(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest); unsigned long\tflags; }; struct irq_domain { struct list_head link; //用于添加到全局链表irq_domain_list中 const char *name; //IRQ domain的名字 const struct irq_domain_ops *ops; //IRQ domain映射操作函数集 void *host_data; //在GIC驱动中，指向了irq_gic_data unsigned int flags; unsigned int mapcount; //映射中断的个数 /* Optional data */ struct fwnode_handle *fwnode; enum irq_domain_bus_token bus_token; struct irq_domain_chip_generic *gc; #ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY struct irq_domain *parent; //支持级联的话，指向父设备 #endif #ifdef CONFIG_GENERIC_IRQ_DEBUGFS struct dentry\t*debugfs_file; #endif /* reverse map data. The linear map gets appended to the irq_domain */ irq_hw_number_t hwirq_max; //IRQ domain支持中断数量的最大值 unsigned int revmap_direct_max_irq; unsigned int revmap_size; //线性映射的大小 struct radix_tree_root revmap_tree; //Radix Tree映射的根节点 unsigned int linear_revmap[]; //线性映射用到的查找表 }; struct irq_domain_ops { int (*match)(struct irq_domain *d, struct device_node *node, enum irq_domain_bus_token bus_token); // 用于中断控制器设备与IRQ domain的匹配 int (*select)(struct irq_domain *d, struct irq_fwspec *fwspec, enum irq_domain_bus_token bus_token); int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); //用于硬件中断号与Linux中断号的映射 void (*unmap)(struct irq_domain *d, unsigned int virq); int (*xlate)(struct irq_domain *d, struct device_node *node, const u32 *intspec, unsigned int intsize, unsigned long *out_hwirq, unsigned int *out_type); //通过device_node，解析硬件中断号和触发方式 #ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY /* extended V2 interfaces to support hierarchy irq_domains */ int (*alloc)(struct irq_domain *d, unsigned int virq, unsigned int nr_irqs, void *arg); void (*free)(struct irq_domain *d, unsigned int virq, unsigned int nr_irqs); void (*activate)(struct irq_domain *d, struct irq_data *irq_data); void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data); int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec, unsigned long *out_hwirq, unsigned int *out_type); #endif }; 关于IRQ domain IRQ domain用于将硬件的中断号，转换成Linux系统中的中断号（virtual irq, virq），来张图：\n每个中断控制器都对应一个IRQ Domain； 中断控制器驱动通过 irq_domain_add_*() 接口来创建 IRQ Domain； IRQ Domain支持三种映射方式：linear map（线性映射），tree map（树映射），no map（不映射） linear map: 维护固定大小的表，索引是硬件中断号，如果硬件中断最大数量固定，并且数值不大，可以选择线性映射； tree map: 硬件中断号可能很大，可以选择树映射； no map: 硬件中断号直接就是Linux的中断号； 三种映射的方式如下图：\n图中描述了三个中断控制器，对应到三种不同的映射方式。各个控制器的硬件中断号可以一样，最终在Linux内核中映射的中断号是唯一的。\n1.2 架构相关代码 中断也是异常模式的一种，当外设触发中断时，处理器会切换到特定的异常模式进行处理，而这部分代码都是架构相关的。ARM64的代码位于 arch/arm64/kernel/entry.S。\nARM64 处理器有四个异常级别 Exception Level：0~3，EL0 对应用户态程序，EL1 对应操作系统内核态，EL2对应Hypervisor，EL3 对应Secure Monitor。\n当异常触发时，处理器进行模式切换，并且跳转到异常向量表开始执行，针对中断异常，最终会跳转到irq_handler 中。代码比较简单，如下：\n1 2 3 4 5 6 7 8 9 10 /* * Interrupt handling. */ .macro\tirq_handler ldr_l\tx1, handle_arch_irq //之前GIC驱动注册好的gic_handle_irq mov\tx0, sp irq_stack_entry blr\tx1 irq_stack_exit .endm 内核整个中断处理流程为：\n中断触发，处理器去异常向量表找到对应的入口，比如EL0的中断跳转到 el0_irq 处，EL1 则跳转到 el1_irq处。在GIC驱动中，会调用 set_handle_irq 接口来设置 handle_arch_irq 的函数指针，让它指向gic_handle_irq，因此中断触发的时候会跳转到 gic_handle_irq 处执行；\ngic_handle_irq 函数处理时，分为两种情况，一种是外设触发的中断，硬件中断号在 16 ~ 1020 之间，一种是软件触发的中断，用于处理器之间的交互，硬件中断号在16以内； 外设触发中断后，根据 irq domain 去查找对应的Linux IRQ中断号，进而得到中断描述符irq_desc，最终也就能调用到外设的中断处理函数了。 GIC/Arch 相关的介绍就此打住，接下来是Linux内核的通用中断处理框架。\n2 通用框架层 上一章主要讲了底层硬件GIC驱动，以及Arch-Specific的中断代码，本文将研究下通用的中断处理的过程，属于硬件无关层。下面的内容将围绕两个问题：\n用户是怎么使用中断的（中断注册）？ 外设触发中断信号时，最终是怎么调用到中断handler的（中断处理）？ 2.1 数据结构分析 先来看一下总的数据结构，核心是围绕着 struct irq_desc 来展开：\nLinux内核的中断处理，围绕着中断描述符结构 struct irq_desc 展开，内核提供了两种中断描述符组织形式：\n打开 CONFIG_SPARSE_IRQ 宏（中断编号不连续），中断描述符以 radix-tree 来组织，用户在初始化时进行动态分配，然后再插入 radix-tree 中； 关闭 CONFIG_SPARSE_IRQ 宏（中断编号连续），中断描述符以数组的形式组织，并且已经分配好； 不管哪种形式，最终都可以通过 linux irq 号来找到对应的中断描述符； 图的左侧灰色部分，上一章已经介绍过，主要**在中断控制器驱动中进行初始化设置，**包括各个结构中函数指针的指向等，其中 struct irq_chip 用于对中断控制器的硬件操作，struct irq_domain 与中断控制器对应，完成的工作是硬件中断号到 Linux irq 的映射。\n图的上侧灰色部分，中断描述符的创建（这里指 CONFIG_SPARSE_IRQ ），主要在获取设备中断信息的过程中完成的，从而让设备树中的中断能与具体的中断描述符 irq_desc 匹配，在后文的中断注册中会介绍。\n图中剩余部分，在设备申请注册中断的过程中进行设置，比如 struct irqaction 中 handler 的设置，这个用于指向我们设备驱动程序中的中断处理函数了。\n中断的处理主要有以下几个核心功能模块：\n硬件中断号到 Linux irq 中断号的映射，并创建好 irq_desc 中断描述符； 中断注册时，先获取设备的中断号，根据中断号找到对应的 irq_desc ，并将设备的中断处理函数添加到 irq_desc 中； 设备触发中断信号时，根据硬件中断号得到 Linux irq 中断号，找到对应的 irq_desc ，最终调用到设备的中断处理函数。 以上功能模块构成了Linux中断框架的核心部分，下面详细分析。\n2.2 中断框架分析 中断注册 首先思考一个问题: 用户是怎么使用中断的？\n熟悉设备驱动的同学应该都清楚，经常会在驱动程序中调用 request_irq() 接口或者request_threaded_irq() 接口来注册设备的中断处理函数； request_irq()/request_threaded_irq 接口中，都需要用到 irq，也就是中断号，那么这个中断号是从哪里来的呢？它是 Linux irq，它又是如何映射到具体的硬件设备的中断号的呢？ 似乎有些跑题了，但实际上在用户进行**中断注册之前内核必然会进行一些基本的设置。**这样就来到了Linux中断框架中一个重要功能模块: 设备硬件中断到 Linux irq 中断号的映射。\n为什么需要中断映射？\n硬件中断号: GIC为每一个硬件中断源都分配了一个唯一编号，称为硬件中断号，用于区分不同的中断源。GIC-v3支持的硬件中断类型和分配的硬件中断号范围如下: 1 2 3 SGI: 0-15 PPI: 16-31 SPI: 21-1019 软件中断号: 系统在中断注册和中断处理过程中使用到的中断号。有的地方也称为虚拟中断号。 为什么要进行中断映射呢？简单来讲，软件可以不需要关注该中断在硬件上是哪个中断来源。简单的SOC内部对中断的管理也比较简单，通常会有一个全局的中断状态寄存器来记录外设中断，这样直接将硬件中断号线性映射到软件中断号即可。但是随着芯片技术的发展，SOC越来越复杂，通常内部会有多个中断控制器（比如GIC interrupt controller, GPIO interrupt controller）, 每一个中断控制器对应多个中断号，而硬件中断号在不同的中断控制器上是会重复编码， 这时仅仅用硬中断号已经不能唯一标识一个外设中断。尤其在多个中断控制器级联的情况下，会变得更加复杂。这样对软件编程来讲极不友好，作为软件工程师，我们更愿意集中精力关注软件层面的内容。\n中断映射的过程如下图:\n硬件设备的中断信息都在设备树 device tree 中进行了描述，在系统启动过程中，这些信息都已经加载到内存中并得到了解析； 驱动中通常会使用 platform_get_irq 或 irq_of_parse_and_map 接口，去根据设备树的信息去创建映射关系（硬件中断号到linux irq中断号映射）； 之前提到过 struct irq_domain 用于完成映射工作，因此在 irq_create_fwspec_mapping 接口中，会先去找到匹配的 irq domain，再去回调该 irq domain 中的函数集 (irq_domain_ops)，通常 irq domain 都是在中断控制器驱动中初始化的，以 ARM GICv2 为例，最终回调到 gic_irq_domain_hierarchy_ops 中的函数；\n如果已经创建好了映射，那么可以直接进行返回 linux irq 中断号了，否则的话需要 irq_domain_alloc_irqs来创建映射关系。irq_domain_alloc_irqs 完成两个工作:\n针对 linux irq 中断号创建一个 irq_desc 中断描述符； 调用 domain-\u0026gt;ops-\u0026gt;alloc 函数来完成映射，在 ARM GICv2 驱动中对应 gic_irq_domain_alloc 函数，这个函数很关键，所以下文重点介绍一下。 gic_irq_domain_alloc 函数如下:\ngic_irq_domain_translate：负责解析出设备树中描述的中断号和中断触发类型（边缘触发、电平触发等）； gic_irq_domain_map：将硬件中断号和linux软中断号绑定到一个结构中，也就完成了映射，此外还绑定了irq_desc 结构中的其他字段，**最重要的是设置了 irq_desc-\u0026gt;handle_irq 的函数指针，这个最终是中断响应时往上执行的入口，**这个是关键，下文讲述中断处理过程时还会提到； 根据硬件中断号的范围设置 irq_desc-\u0026gt;handle_irq 的指针，共享中断入口为 handle_fasteoi_irq，私有中断入口为 handle_percpu_devid_irq； 上述函数执行完成后，完成了两大工作：\n硬件中断号与Linux中断号完成映射，并为Linux中断号创建了irq_desc中断描述符； 数据结构的绑定及初始化，关键的地方是设置了中断处理执行流程的入口； 内核已经完成了基本的设置，即为中断注册做好了充分准备，我们现在可以正式开启中断注册的流程了：\n设备驱动中，获取到了 irq 中断号后，通常就会采用 request_irq/request_threaded_irq 来注册中断，其中request_irq 用于注册普通处理的中断，request_threaded_irq 用于注册线程化处理的中断。在讲具体的注册流程前，先看一下主要的中断标志位：\n1 2 3 4 5 6 7 8 9 10 11 12 #define IRQF_SHARED\t0x00000080 //多个设备共享一个中断号，需要外设硬件支持 #define IRQF_PROBE_SHARED\t0x00000100 //中断处理程序允许sharing mismatch发生 #define __IRQF_TIMER\t0x00000200 //时钟中断 #define IRQF_PERCPU\t0x00000400 //属于特定CPU的中断 #define IRQF_NOBALANCING\t0x00000800 //禁止在CPU之间进行中断均衡处理 #define IRQF_IRQPOLL\t0x00001000 //中断被用作轮训 #define IRQF_ONESHOT\t0x00002000 //一次性触发的中断，不能嵌套，1）在硬件中断处理完成后才能打开中断；2）在中断线程化中保持关闭状态，直到该中断源上的所有thread_fn函数都执行完 #define IRQF_NO_SUSPEND\t0x00004000 //系统休眠唤醒操作中，不关闭该中断 #define IRQF_FORCE_RESUME\t0x00008000 //系统唤醒过程中必须强制打开该中断 #define IRQF_NO_THREAD\t0x00010000 //禁止中断线程化 #define IRQF_EARLY_RESUME\t0x00020000 //系统唤醒过程中在syscore阶段resume，而不用等到设备resume阶段 #define IRQF_COND_SUSPEND\t0x00040000 //与NO_SUSPEND的用户共享中断时，执行本设备的中断处理函数 中断注册流程如下图：\nrequest_irq 也是调用 request_threaded_irq，只是在传参的时候，线程处理函数 thread_fn 函数设置成 NULL； 由于在硬件中断号和Linux中断号完成映射后，irq_desc 已经创建好，可以通过 irq_to_desc 接口去获取对应的 irq_desc； 创建 irqaction，并初始化该结构体中的各个字段，其中包括传入的中断处理函数赋值给对应的字段； __setup_irq 用于完成中断的相关设置，包括中断线程化的处理： 中断线程化用于减少系统关中断的时间，增强系统的实时性； ARM64 默认开启了 CONFIG_IRQ_FORCED_THREADING，引导参数传入 threadirqs 时，则除了IRQF_NO_THREAD外的中断，其他的都将强制线程化处理； 中断线程化会为每个中断都创建一个内核线程，如果中断进行共享，对应irqaction将连接成链表，每个irqaction 都有 thread_mask 位图字段，当所有共享中断都处理完成后才能 unmask 中断，解除中断屏蔽； 中断处理 当完成中断的注册后，所有结构的组织关系都已经建立好，剩下的工作就是当设备中断信号来临时，进行中断的处理工作。回顾下 Arch-specific 的中断处理流程：\n中断收到之后，首先会跳转到异常向量表的入口处，进而逐级进行回调处理，最终调用到 generic_handle_irq来进行中断处理。generic_handle_irq处理如下图：\ngeneric_handle_irq 函数最终会调用到 desc-\u0026gt;handle_irq()，这个也就是对应到上文中在建立映射关系的过程中，调用 irq_domain_set_info 函数，设置好了函数指针，也就是 handle_fasteoi_irq 和handle_percpu_devid_irq，下面看这两个函数：\n**handle_fasteoi_irq：**处理共享中断，并且遍历 irqaction 链表，逐个调用 action-\u0026gt;handler()函数，这个函数正是设备驱动程序调用request_irq/request_threaded_irq接口注册的中断处理函数，此外如果中断线程化处理的话，还会调用__irq_wake_thread()唤醒内核线程； **handle_percpu_devid_irq：**处理per-CPU中断处理，在这个过程中会分别调用中断控制器的处理函数进行硬件操作，该函数同样也会调用 action-\u0026gt;handler() 来进行中断处理； 中断线程化处理 中断线程化处理后的唤醒流程 __handle_irq_event_percpu-\u0026gt;__irq_wake_thread：\n中断线程初始化：irq_thread 内核线程，将根据是否为强制中断线程化对函数指针 handler_fn 进行初始化，以便后续进行调用。 中断线程执行：irq_thread 内核线程将在 while(!irq_wait_for_interrupt) 循环中进行中断的处理，当满足条件时，执行handler_fn，在该函数中最终调用 action-\u0026gt;thread_fn，也就是完成了中断的处理； 中断线程唤醒条件判定：irq_wait_for_interrupt 函数，将会判断中断线程的唤醒条件，如果满足了，则将当前任务设置成TASK_RUNNING 状态，并返回 0，这样就能执行中断的处理，否则就调用 schedule() 进行调度，让出CPU，并将任务设置成 TASK_INTERRUPTIBLE 可中断睡眠状态； 2.3 总结 中断的处理，总体来说可以分为两部分来看：\n**自顶向下：围绕 irq_desc 中断描述符建立好连接关系，这个过程就包括：中断源信息的解析（设备树），硬件中断号到Linux中断号的映射、irq_desc 结构的分配及初始化（内部各个结构的组织关系）、中断的注册（填充 irq_desc 结构，包括handler处理函数）等，总而言之，就是完成静态关系创建，为中断处理做好准备； ***自底向上：***当外设触发中断信号时，中断控制器接收到信号并发送到处理器，此时处理器进行异常模式切换，并逐步从处理器架构相关代码逐级回调。如果涉及到中断线程化，则还需要进行中断内核线程的唤醒操作，最终完成中断处理函数的执行。 ","date":"2024-10-16T18:14:17+08:00","permalink":"https://zcxggmu.github.io/p/linux-interrupt-handle_1/","title":"Linux Interrupt Handle_1"},{"content":"hugo_auto_workflow\n","date":"2024-10-16T16:13:20+08:00","permalink":"https://zcxggmu.github.io/p/hello_hugo/","title":"Hello_hugo"},{"content":"??? ","date":"2024-10-16T16:10:44+08:00","permalink":"https://zcxggmu.github.io/p/mysecond/","title":"MySecond"},{"content":"hello hugo ","date":"2024-10-16T15:50:18+08:00","permalink":"https://zcxggmu.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://zcxggmu.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://zcxggmu.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://zcxggmu.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://zcxggmu.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://zcxggmu.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://zcxggmu.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://zcxggmu.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://zcxggmu.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://zcxggmu.github.io/p/emoji-support/","title":"Emoji Support"}]