<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zcxggmu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="riscv vector内核异常处理、调度机制分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux RISC-V Vector支持">
<meta property="og:url" content="https://zcxggmu.github.io/2025/11/11/Linux-RISC-V-Vector%E6%94%AF%E6%8C%81/index.html">
<meta property="og:site_name" content="zcxGGmu&#39;s blog">
<meta property="og:description" content="riscv vector内核异常处理、调度机制分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/v2-e7e8927ab88d08fdf59e5c6d7fdf3529_b.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202401101626365.png">
<meta property="article:published_time" content="2025-11-11T02:23:22.000Z">
<meta property="article:modified_time" content="2025-11-11T02:39:05.936Z">
<meta property="article:author" content="zcxGGmu">
<meta property="article:tag" content="SIMD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-e7e8927ab88d08fdf59e5c6d7fdf3529_b.jpg">

<link rel="canonical" href="https://zcxggmu.github.io/2025/11/11/Linux-RISC-V-Vector%E6%94%AF%E6%8C%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux RISC-V Vector支持 | zcxGGmu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zcxGGmu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">行远自迩，登高自卑</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zcxggmu.github.io/2025/11/11/Linux-RISC-V-Vector%E6%94%AF%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zcxGGmu">
      <meta itemprop="description" content="kernel/kvm, arm/riscv, llm/agent">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zcxGGmu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux RISC-V Vector支持
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-11 10:23:22 / 修改时间：10:39:05" itemprop="dateCreated datePublished" datetime="2025-11-11T10:23:22+08:00">2025-11-11</time>
            </span>

          
            <div class="post-description">riscv vector内核异常处理、调度机制分析</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0-参考"><a href="#0-参考" class="headerlink" title="0 参考"></a>0 参考</h1><ul>
<li><p>[vector-isa-support]([<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20230518161949.11203-1-andy.chiu@sifive.com/">PATCH -next v20 00&#x2F;26] riscv: Add vector ISA support - Andy Chiu (kernel.org)</a>)</p>
</li>
<li><p>[vector-1.0-spec](<a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-v-spec">riscv&#x2F;riscv-v-spec: Working draft of the proposed RISC-V V vector extension (github.com)</a>)</p>
</li>
<li><p>[vector-1.0解读](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/674158689">【个人笔记】RISC-V “V” Vector Extension Version 1.0 - 知乎 (zhihu.com)</a>)</p>
</li>
</ul>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>[<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20230605110724.21391-1-andy.chiu@sifive.com/">PATCH -next v21 00&#x2F;27] riscv: Add vector ISA support - Andy Chiu (kernel.org)</a>在这个实现中，有一些假设：</p>
<ol>
<li>我们假设系统中的所有harts都具有相同的ISA。</li>
<li>默认情况下，我们在内核和用户空间中禁用向量。只有在一个非法指令陷阱（第一次使用陷阱）中，实际开始执行向量后，才启用用户的向量。</li>
<li>我们检测 “riscv,isa” 来确定是否支持向量。</li>
</ol>
<p>我们在结构体 <code>thread_struct</code> 中定义了一个新的结构体 <code>__riscv_v_ext_state</code>，用于保存&#x2F;恢复与向量相关的寄存器。它用于内核空间和用户空间。</p>
<ul>
<li>在内核空间中，<code>__riscv_v_ext_state</code> 中的 datap 指针将被分配用于保存向量寄存器。</li>
<li>在用户空间中：<ul>
<li>在用户空间的信号处理器中，该结构体位于 <code>__riscv_ctx_hdr</code> 之后，该结构体嵌入在fp保留区域中。这是为了避免ABI中断。并且datap指向 <code>__riscv_v_ext_state</code> 的末尾。</li>
<li>在ptrace中，数据将被放入ubuf中，我们使用 <code>riscv_vr_get()/riscv_vr_set()</code> 从ubuf中获取或设置 <code>__riscv_v_ext_state</code> 数据结构，datap指针将被清零，向量寄存器将被复制到ubuf中 <code>__riscv_v_ext_state</code> 结构体后的地址。</li>
</ul>
</li>
</ul>
<hr>
<p>重点关注以下几点：</p>
<ul>
<li>vector的Trap处理</li>
<li>vector的上下文保存与恢复</li>
</ul>
<h1 id="2-解析"><a href="#2-解析" class="headerlink" title="2 解析"></a>2 解析</h1><h2 id="2-1-vector-trap"><a href="#2-1-vector-trap" class="headerlink" title="2.1 vector_trap"></a>2.1 vector_trap</h2><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p><img src="https://pic2.zhimg.com/v2-e7e8927ab88d08fdf59e5c6d7fdf3529_b.jpg" alt="img"></p>
<blockquote>
<ul>
<li><code>mstatus/sstatus</code></li>
</ul>
<p>A vector context status field, <code>VS</code>, is added to <code>mstatus[10:9]</code> and shadowed in <code>sstatus[10:9]</code>. It is defined analogously to the floating-point context status field, <code>FS</code>.</p>
<p><font color='red'><strong>Attempts to execute any vector instruction, or to access the vector CSRs, raise an illegal-instruction exception when <code>mstatus.VS</code> is set to Off.</strong></font></p>
<p>When <code>mstatus.VS</code> is set to Initial or Clean, executing any instruction that changes vector state, including the vector CSRs, will change <code>mstatus.VS</code> to Dirty. Implementations may also change <code>mstatus.VS</code> from Initial or Clean to Dirty at any time, even when there is no change in vector state.</p>
<ul>
<li><code>vsstatus</code></li>
</ul>
<p>When the hypervisor extension is present, a vector context status field, <code>VS</code>, is added to <code>vsstatus[10:9]</code>. It is defined analogously to the floating-point context status field, <code>FS</code>.</p>
<p><strong><font color='red'>When V&#x3D;1, both <code>vsstatus.VS</code> and <code>mstatus.VS</code> are in effect: attempts to execute any vector instruction, or to access the vector CSRs, raise an illegal-instruction exception when either field is set to Off.</font></strong></p>
<p>When V&#x3D;1 and neither <code>vsstatus.VS</code> nor <code>mstatus.VS</code> is set to Off, executing any instruction that changes vector state, including the vector CSRs, will change both <code>mstatus.VS</code> and <code>vsstatus.VS</code> to Dirty. Implementations may also change <code>mstatus.VS</code> or <code>vsstatus.VS</code> from Initial or Clean to Dirty at any time, even when there is no change in vector state.</p>
<p>If <code>vsstatus.VS</code> is Dirty, <code>vsstatus.SD</code> is 1; otherwise, <code>vsstatus.SD</code> is set in accordance with existing specifications.</p>
<p>If <code>mstatus.VS</code> is Dirty, <code>mstatus.SD</code> is 1; otherwise, <code>mstatus.SD</code> is set in accordance with existing specifications.</p>
<p>For implementations with a writable <code>misa.V</code> field, the <code>vsstatus.VS</code> field may exist even if <code>misa.V</code> is clear.</p>
</blockquote>
<hr>
<h3 id="fpsimd-state"><a href="#fpsimd-state" class="headerlink" title="fpsimd_state"></a>fpsimd_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">riscv_fp_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">riscv_f_ext_state</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">riscv_d_ext_state</span> <span class="title">d</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">riscv_q_ext_state</span> <span class="title">q</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">riscv_v_ext_state</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vstart;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vl;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vtype;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vcsr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vlenb;</span><br><span class="line">	<span class="type">void</span> *datap;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In signal handler, datap will be set a correct user stack offset</span></span><br><span class="line"><span class="comment">	 * and vector registers will be copied to the address of datap</span></span><br><span class="line"><span class="comment">	 * pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑到 <code>vector_context</code> 的大小可能变化且可能很大，它们被保存在动态分配的内存中，由<code>__riscv_v_ext_state</code> 中的datap指针指向。</p>
<h3 id="trap-control-handle"><a href="#trap-control-handle" class="headerlink" title="trap_control&#x2F;handle"></a>trap_control&#x2F;handle</h3><p>流程如下：</p>
<ul>
<li><p>系统启动，主&#x2F;从核拉起时，设置fpsimd为OFF状态；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(_start_kernel)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable FPU &amp; VECTOR to detect illegal usage of</span></span><br><span class="line"><span class="comment">	 * floating point or vector in kernel space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	li t0, SR_FS_VS</span><br><span class="line">	csrc CSR_STATUS, t0</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	.global secondary_start_sbi</span><br><span class="line">secondary_start_sbi:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable FPU &amp; VECTOR to detect illegal usage of</span></span><br><span class="line"><span class="comment">	 * floating point or vector in kernel space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	li t0, SR_FS_VS</span><br><span class="line">	csrc CSR_STATUS, t0</span><br></pre></td></tr></table></figure>
</li>
<li><p>进程在用户态首次执行fpsimd指令，陷入处理并返回：</p>
<p>向量单元默认情况下对所有用户进程都是禁用的。因此当进程首次使用向量时，它会因非法指令而陷入内核。只有在那之后，内核才会为该用户进程分配vector上下文，并开始管理该上下文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">riscv_v_thread_zalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *datap;</span><br><span class="line"></span><br><span class="line">	datap = kzalloc(riscv_v_vsize, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!datap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	current-&gt;thread.vstate.datap = datap;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;current-&gt;thread.vstate, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> __riscv_v_ext_state,</span><br><span class="line">						    datap));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">riscv_v_first_use_handler</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 __user *epc = (u32 __user *)regs-&gt;epc;</span><br><span class="line">	u32 insn = (u32)regs-&gt;badaddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do not handle if V is not supported, or disabled */</span></span><br><span class="line">	<span class="keyword">if</span> (!(ELF_HWCAP &amp; COMPAT_HWCAP_ISA_V))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If V has been enabled then it is not the first-use trap */</span></span><br><span class="line">	<span class="keyword">if</span> (riscv_v_vstate_query(regs))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the instruction */</span></span><br><span class="line">	<span class="keyword">if</span> (!insn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (__get_user(insn, epc))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filter out non-V instructions */</span></span><br><span class="line">	<span class="keyword">if</span> (!insn_is_vector(insn))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity check. datap should be null by the time of the first-use trap */</span></span><br><span class="line">	WARN_ON(current-&gt;thread.vstate.datap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now we sure that this is a V instruction. And it executes in the</span></span><br><span class="line"><span class="comment">	 * context where VS has been off. So, try to allocate the user&#x27;s V</span></span><br><span class="line"><span class="comment">	 * context and resume execution.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (riscv_v_thread_zalloc()) &#123;</span><br><span class="line">		force_sig(SIGBUS);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	riscv_v_vstate_on(regs);</span><br><span class="line">	riscv_v_vstate_restore(current, regs);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户态首次vector_trap将分配实际内存，用于保存&#x2F;恢复vector上下文，返回用户态之前将 <code>sstatus.VS</code> 设置为Initial。之后用户态将正常使用vector。</p>
</li>
</ul>
<h2 id="2-2-vector-context-switch"><a href="#2-2-vector-context-switch" class="headerlink" title="2.2 vector_context_switch"></a>2.2 vector_context_switch</h2><p>相较于通用寄存器组，vector上下文更庞大。因此在大量使用vector的场景中，需要尽可能的避免vector上下文的保存&#x2F;恢复，降低系统开销。在多核多进程系统中，内核需要跟踪比对 <code>task - cpu</code> 的 (绑定指向) 状态以确定某一次的vector上下文的保存&#x2F;恢复上是否 “真的有必要”。先看一下目前内核在该问题的处理方式。</p>
<h3 id="kernel-context-save-restore"><a href="#kernel-context-save-restore" class="headerlink" title="kernel: context_save&#x2F;restore"></a>kernel: context_save&#x2F;restore</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">riscv_v_vstate_save</span><span class="params">(<span class="keyword">struct</span> task_struct *task,</span></span><br><span class="line"><span class="params">				       <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((regs-&gt;status &amp; SR_VS) == SR_VS_DIRTY) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> __<span class="title">riscv_v_ext_state</span> *<span class="title">vstate</span> =</span> &amp;task-&gt;thread.vstate;</span><br><span class="line"></span><br><span class="line">		__riscv_v_vstate_save(vstate, vstate-&gt;datap);</span><br><span class="line">		__riscv_v_vstate_clean(regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">riscv_v_vstate_restore</span><span class="params">(<span class="keyword">struct</span> task_struct *task,</span></span><br><span class="line"><span class="params">					  <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((regs-&gt;status &amp; SR_VS) != SR_VS_OFF) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> __<span class="title">riscv_v_ext_state</span> *<span class="title">vstate</span> =</span> &amp;task-&gt;thread.vstate;</span><br><span class="line"></span><br><span class="line">		__riscv_v_vstate_restore(vstate, vstate-&gt;datap);</span><br><span class="line">		__riscv_v_vstate_clean(regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __switch_to_vector(<span class="keyword">struct</span> task_struct *prev,</span><br><span class="line">				      <span class="keyword">struct</span> task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span>;</span></span><br><span class="line"></span><br><span class="line">	regs = task_pt_regs(prev);</span><br><span class="line">	riscv_v_vstate_save(prev, regs);</span><br><span class="line">	riscv_v_vstate_restore(next, task_pt_regs(next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector-1.0-spec</code> 中有一句注释：</p>
<blockquote>
<p>Accurate setting of <code>mstatus.VS</code> is an optimization. Software will typically use VS to reduce context-swap overhead.</p>
</blockquote>
<p>内核中也确实这么做了，这是硬件的优化机制：</p>
<ul>
<li>vector上下文如果为DIRTY状态，保存的时候就必须去硬件上拉取最新的内容，否则就不需要做任何工作；</li>
<li>vector上下文如果为OFF状态，恢复的时候就无需做任何工作，否则就必须恢复vector上下文状态；</li>
</ul>
<hr>
<p>内核最近提了一组<a target="_blank" rel="noopener" href="https://lore.kernel.org/linux-riscv/20240108035209.GA212605@sol.localdomain/T/#mda836061caf7a5db9b6994a58ec8e32721ae5038">PATCH</a>，考虑了这样一种调度场景：</p>
<blockquote>
<p>用户只有在内核真正返回到用户空间后才会使用其向量寄存器。因此，只要我们还在内核模式下运行，可以延迟恢复向量寄存器。内核需要添加一个线程标志以指示是否需要恢复向量，并在最后的特定于架构的退出用户模式的临界点处进行恢复。这样可以节省在内核模式下切换多个运行V操作的进程时的上下文恢复开销。</p>
<p>举个例子：如果内核执行 <code>A-&gt;B-&gt;C</code> 的上下文切换，并最终返回到 C 的用户空间，那么就没有必要恢复 B 的vector寄存器。</p>
<p>此外，这还可以防止我们在多次执行内核模式的向量操作时重复恢复vector上下文。这样做的代价是，在执行 <code>vstate_{save,restore}</code> 期间我们必须禁用抢占并将向量标记为忙碌。因为如果在 <code>vstate_{save,restore}</code> 过程中发生导致陷阱的上下文切换，vector上下文将不会立即恢复。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/MaskerDad/BlogImage@main/202401101626365.png" alt="image-20240110162607218"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">riscv_v_first_use_handler</span><br><span class="line">    +-&gt; riscv_v_vstate_set_restore</span><br><span class="line">__switch_to_vector</span><br><span class="line">    +-&gt; riscv_v_vstate_set_restore</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIF_RISCV_V_DEFER_RESTORE	12 <span class="comment">/* restore Vector before returing to user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIF_RISCV_V_DEFER_RESTORE	(1 &lt;&lt; TIF_RISCV_V_DEFER_RESTORE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">riscv_v_vstate_set_restore</span><span class="params">(<span class="keyword">struct</span> task_struct *task, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((regs-&gt;status &amp; SR_VS) != SR_VS_OFF) &#123;</span><br><span class="line">		set_tsk_thread_flag(task, TIF_RISCV_V_DEFER_RESTORE);</span><br><span class="line">		riscv_v_vstate_on(regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_exit_to_user_mode_prepare</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs,</span></span><br><span class="line"><span class="params">+						  <span class="type">unsigned</span> <span class="type">long</span> ti_work)</span></span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="keyword">if</span> (ti_work &amp; _TIF_RISCV_V_DEFER_RESTORE) &#123;</span><br><span class="line">+		clear_thread_flag(TIF_RISCV_V_DEFER_RESTORE);</span><br><span class="line">+		<span class="comment">/*</span></span><br><span class="line"><span class="comment">+		 * We are already called with irq disabled, so go without</span></span><br><span class="line"><span class="comment">+		 * keeping track of riscv_v_flags.</span></span><br><span class="line"><span class="comment">+		 */</span></span><br><span class="line">+		riscv_v_vstate_restore(current, regs);</span><br><span class="line">+	&#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> arch_exit_to_user_mode_prepare arch_exit_to_user_mode_prepare</span></span><br></pre></td></tr></table></figure>

<p>总体来说，将vector恢复工作推迟到返回用户态的节点，有两个优势：</p>
<ul>
<li>S-Mode下无论发生了多少次抢占，内核只关注返回用户态的那个task，中间的多个 <code>task_vector_context</code> 没必要恢复；</li>
<li>S-Mode下也可能会使用vector，这种情况下会覆盖掉用户态的vector上下文，内核必须在使用vector前保存用户态vector上下文，在使用vector结束时恢复。但S-Mode有可能多次执行向量操作时，内核没必要重复恢复vector上下文，因此也是标记一个 <code>REFER_RESTORE</code>，一并推迟到返回用户态的节点；</li>
</ul>
<h3 id="kvm-context-save-restore"><a href="#kvm-context-save-restore" class="headerlink" title="kvm: context_save&#x2F;restore"></a>kvm: context_save&#x2F;restore</h3><p><a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20230518161949.11203-20-andy.chiu@sifive.com/">KVM: Add vector lazy save&#x2F;restore support</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">kvm_arch_vcpu_load</span><br><span class="line">    +-&gt; kvm_riscv_vcpu_host_fp_save(&amp;vcpu-&gt;arch.host_context);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_guest_fp_restore(&amp;vcpu-&gt;arch.guest_context, vcpu-&gt;arch.isa);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_host_vector_save(&amp;vcpu-&gt;arch.host_context);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_guest_vector_restore(&amp;vcpu-&gt;arch.guest_context, vcpu-&gt;arch.isa);</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_put</span><br><span class="line">    +-&gt; kvm_riscv_vcpu_guest_fp_save(&amp;vcpu-&gt;arch.guest_context, vcpu-&gt;arch.isa);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_host_fp_restore(&amp;vcpu-&gt;arch.host_context);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_guest_vector_save(&amp;vcpu-&gt;arch.guest_context, vcpu-&gt;arch.isa);</span><br><span class="line">	+-&gt; kvm_riscv_vcpu_host_vector_restore(&amp;vcpu-&gt;arch.host_context);</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_load(vcpu);</span><br><span class="line"><span class="keyword">while</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    __guest_enter();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ret = handle_exit(vcpu);</span><br><span class="line">&#125;</span><br><span class="line">kvm_arch_vcpu_put(vcpu);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_riscv_vcpu_guest_vector_save</span><span class="params">(<span class="keyword">struct</span> kvm_cpu_context *cntx,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> *isa)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((cntx-&gt;sstatus &amp; SR_VS) == SR_VS_DIRTY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (riscv_isa_extension_available(isa, v))</span><br><span class="line">			__kvm_riscv_vector_save(cntx);</span><br><span class="line">		kvm_riscv_vcpu_vector_clean(cntx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_riscv_vcpu_guest_vector_restore</span><span class="params">(<span class="keyword">struct</span> kvm_cpu_context *cntx,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">long</span> *isa)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((cntx-&gt;sstatus &amp; SR_VS) != SR_VS_OFF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (riscv_isa_extension_available(isa, v))</span><br><span class="line">			__kvm_riscv_vector_restore(cntx);</span><br><span class="line">		kvm_riscv_vcpu_vector_clean(cntx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_riscv_vcpu_host_vector_save</span><span class="params">(<span class="keyword">struct</span> kvm_cpu_context *cntx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* No need to check host sstatus as it can be modified outside */</span></span><br><span class="line">	<span class="keyword">if</span> (riscv_isa_extension_available(<span class="literal">NULL</span>, v))</span><br><span class="line">		__kvm_riscv_vector_save(cntx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_riscv_vcpu_host_vector_restore</span><span class="params">(<span class="keyword">struct</span> kvm_cpu_context *cntx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (riscv_isa_extension_available(<span class="literal">NULL</span>, v))</span><br><span class="line">		__kvm_riscv_vector_restore(cntx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的缺陷：</p>
<ul>
<li><p>对于 <code>kvm_arch_vcpu_load</code>：</p>
<ul>
<li><p><code>kvm_riscv_vcpu_host_fp_save/kvm_riscv_vcpu_host_vector_save</code></p>
<p>仅检查是否支持f扩展，就直接保存host状态 &#x3D;&gt; 考虑guest对fp&#x2F;vector的使用情况，应该延迟保存</p>
</li>
<li><p><code>kvm_riscv_vcpu_guest_fp_restore/kvm_riscv_vcpu_guest_vector_restore</code></p>
<p>仅检查 <code>vsstatus.FS != SR_FS_OFF</code> 和 <code>vsstatus.VS != SR_VS_OFF </code>，说明guest已允许float&#x2F;vector指令的执行，直接恢复guest状态</p>
<ul>
<li>如果条件判断为guest禁用了float&#x2F;vector_trap，恢复其上下文完全没有问题；但考虑这样一种情况：host没使用过float&#x2F;vector指令，当前pCPU的float&#x2F;vector寄存器仅为guest所用，guest此时完全不需要执行本次恢复工作。</li>
<li>如果条件判断为guest启用了float&#x2F;vector_trap，那么之前的host状态完全没必须要保存；</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SIMD/" rel="tag"># SIMD</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/11/11/KVM-ARM-SVE%E8%99%9A%E6%8B%9F%E5%8C%96%E6%94%AF%E6%8C%81/" rel="prev" title="KVM/ARM SVE虚拟化支持">
      <i class="fa fa-chevron-left"></i> KVM/ARM SVE虚拟化支持
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/11/11/cpu%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="next" title="cpu虚拟化">
      cpu虚拟化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-%E5%8F%82%E8%80%83"><span class="nav-number">1.</span> <span class="nav-text">0 参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">1 背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%A7%A3%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">2 解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-vector-trap"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 vector_trap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ISA"><span class="nav-number">3.1.1.</span> <span class="nav-text">ISA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fpsimd-state"><span class="nav-number">3.1.2.</span> <span class="nav-text">fpsimd_state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-control-handle"><span class="nav-number">3.1.3.</span> <span class="nav-text">trap_control&#x2F;handle</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-vector-context-switch"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 vector_context_switch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-context-save-restore"><span class="nav-number">3.2.1.</span> <span class="nav-text">kernel: context_save&#x2F;restore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kvm-context-save-restore"><span class="nav-number">3.2.2.</span> <span class="nav-text">kvm: context_save&#x2F;restore</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zcxGGmu</p>
  <div class="site-description" itemprop="description">kernel/kvm, arm/riscv, llm/agent</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zcxGGmu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
